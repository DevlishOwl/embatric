import{colorMix as n,getStyleFromHsl as t,getStyleFromRgb as i,drawLine as e,ExternalInteractorBase as o,isInArray as a}from"tsparticles-engine";class ConnectLinks{constructor(){this.opacity=.5}load(n){n&&void 0!==n.opacity&&(this.opacity=n.opacity)}}class
Connect{constructor(){this.distance=80;this.links=new ConnectLinks;this.radius=60}get lineLinked(){return this.links}set lineLinked(n){this.links=n}get line_linked(){return this.links}set line_linked(n){this.links=n}load(n){var t,i;if(n){void 0!==n.distance&&(this.distance=n.distance);this.links.load(null!==(i=null!==(t=n.links)&&void
0!==t?t:n.lineLinked)&&void 0!==i?i:n.line_linked);void 0!==n.radius&&(this.radius=n.radius)}}}function gradient(e,o,a,c){const s=Math.floor(a.getRadius()/o.getRadius()),r=o.getFillColor(),d=a.getFillColor();if(!r||!d)return;const l=o.getPosition(),u=a.getPosition(),v=n(r,d,o.getRadius(),a.getRadius()),h=e.createLinearGradient(l.x,l.y,u.x,u.y);h.addColorStop(0,t(r,c));h.addColorStop(s>1?1:s,i(v,c));h.addColorStop(1,t(d,c));return
h}function drawConnectLine(n,t,i,o,a){e(n,o,a);n.lineWidth=t;n.strokeStyle=i;n.stroke()}function lineStyle(n,t,i,e){const o=n.actualOptions,a=o.interactivity.modes.connect;if(a)return gradient(t,i,e,a.links.opacity)}function drawConnection(n,t,i){n.canvas.draw((e=>{var
o;const a=lineStyle(n,e,t,i);if(!a)return;const c=t.getPosition(),s=i.getPosition();drawConnectLine(e,null!==(o=t.retina.linksWidth)&&void 0!==o?o:0,a,c,s)}))}class Connector extends o{constructor(n){super(n)}clear(){}init(){const n=this.container,t=n.actualOptions.interactivity.modes.connect;if(t){n.retina.connectModeDistance=t.distance*n.retina.pixelRatio;n.retina.connectModeRadius=t.radius*n.retina.pixelRatio}}async
interact(){const n=this.container,t=n.actualOptions;if(t.interactivity.events.onHover.enable&&"pointermove"===n.interactivity.status){const t=n.interactivity.mouse.position;if(!n.retina.connectModeDistance||n.retina.connectModeDistance
<0||!n.retina.connectModeRadius||n.retina.connectModeRadius<0||!t)return;const
    i=Math.abs(n.retina.connectModeRadius),e=n.particles.quadTree.queryCircle(t,i,(n=>this.isEnabled(n)));let o=0;for(const t of e){const i=t.getPosition();for(const a of e.slice(o+1)){const e=a.getPosition(),o=Math.abs(n.retina.connectModeDistance),c=Math.abs(i.x-e.x),s=Math.abs(i.y-e.y);c
    <o&&s<o&&drawConnection(n,t,a)}++o}}}isEnabled(n){var
        t;const i=this.container,e=i.interactivity.mouse,o=(null!==(t=null===n||void 0===n?void 0:n.interactivity)&&void 0!==t?t:i.actualOptions.interactivity).events;return!(!o.onHover.enable||!e.position)&&a( "connect",o.onHover.mode)}loadModeOptions(n,...t){n.connect||(n.connect=new
        Connect);for(const i of t)n.connect.load(null===i||void 0===i?void 0:i.connect)}reset(){}}async function loadExternalConnectInteraction(n){await n.addInteractor( "externalConnect",(n=>new Connector(n)))}export{Connect,ConnectLinks,loadExternalConnectInteraction}; //# sourceMappingURL=index.js.map