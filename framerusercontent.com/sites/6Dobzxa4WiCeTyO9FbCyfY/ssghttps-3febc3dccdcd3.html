import{clamp as o,circleBounce as e,circleBounceDataFromParticle as i,ParticlesInteractorBase as s,getDistance as t}from"tsparticles-engine";function updateAbsorb(e,i,s,t,n,a){const r=o(e.options.collisions.absorb.speed*n.factor/10,0,t);e.size.value+=r/2;s.size.value-=r;if(t
<=a){s.size.value=0;s.destroy()}}function
    absorb(o,e,i,s){const t=o.getRadius(),n=e.getRadius();void 0===t&&void 0!==n?o.destroy():void 0!==t&&void 0===n?e.destroy():void 0!==t&&void 0!==n&&(t>=n?updateAbsorb(o,t,e,n,i,s):updateAbsorb(e,n,o,t,i,s))}function bounce(o,s){e(i(o),i(s))}function destroy(o,e){o.unbreakable||e.unbreakable||bounce(o,e);if(void 0===o.getRadius()&&void 0!==e.getRadius())o.destroy();else if(void 0!==o.getRadius()&&void
    0===e.getRadius())e.destroy();else if(void 0!==o.getRadius()&&void 0!==e.getRadius()){const i=o.getRadius()>=e.getRadius()?o:e;i.destroy()}}function resolveCollision(o,e,i,s){switch(o.options.collisions.mode){case"absorb":absorb(o,e,i,s);break;case"bounce":bounce(o,e);break;case"destroy":destroy(o,e);break}}class
    Collider extends s{constructor(o){super(o)}clear(){}init(){}async interact(o,e){const i=this.container,s=o.getPosition(),n=o.getRadius(),a=i.particles.quadTree.queryCircle(s,2*n);for(const r of a){if(o===r||!r.options.collisions.enable||o.options.collisions.mode!==r.options.collisions.mode||r.destroyed||r.spawning)continue;const
    a=r.getPosition(),d=r.getRadius();if(Math.abs(Math.round(s.z)-Math.round(a.z))>n+d)continue;const l=t(s,a),c=n+d;l>c||resolveCollision(o,r,e,i.retina.pixelRatio)}}isEnabled(o){return o.options.collisions.enable}reset(){}}async function loadParticlesCollisionsInteraction(o){await
    o.addInteractor("particlesCollisions",(o=>new Collider(o)))}export{loadParticlesCollisionsInteraction}; //# sourceMappingURL=index.js.map